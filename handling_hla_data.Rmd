---
title: "HLA data import, transformation, integration"
author: "Chris Hammer and Maciej Migdał"
date: "07/18/2018"
output: 
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: cerulean
---

##Part 1: Data import, transformation, integration

```{r setup, include=FALSE, echo=TRUE}
knitr::opts_chunk$set(echo = TRUE)
devtools::load_all()
library("kableExtra")
library("dplyr")
```

###Import of HLA alleles

> We have benchmarked several HLA inference tools for WGS data. “HLA-HD” turned out to be the method of choice. “HIBAG” or “SNP2HLA” are established solutions for imputations from SNP genotyping. For the sake of simplicity, let’s import a data table with HLA allele calls that are already in the desired 4-digit resolution:
> This example data is from HLA-HD. This software infers allele status for most HLA genes, not only the “classical” ones. It would be good to have a check in place to make sure the format is correct (x*xx:xx).

The input file for the package are HLA alleles calls format of tab separated
table, with column names. The first column have to hold IDs of samples, and
the rest of columns the HLA alleles calls. 

MiDAS package offers `readHlaCalls` function for reading input file. Under the
hood function check the input file for compilance with the HLA allele calls 
file format (as specifed above). Moreover the HLA numbers are checked for 
compilance with HLA allele numbers format, using `checkAlleleFormat` function.
Finally the column names are created based on the HLA numbers in specific 
columns, ensuring that the colum naming is consistient.

Let's see that in an example
```{r read_hla_calls, echo=TRUE}
# checkAlleleFormat can be used to check HLA numbers format
hla_numbers <- c("A*01:01", "A*01:02", "foo", "bar")
checkAlleleFormat(hla_numbers)

# readHlaCalls reads the input file
file <- system.file("extdata", "HLAHD_output_example.txt", package = "MiDAS")
hla_calls <- readHlaCalls(file)

kable(hla_calls) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(width = "100%", height = "200px")
```

###Inference of amino acid variation from HLA allele status
> This is probably the most important and urgent issue to solve. Amino acid alignments for all known HLA alleles (one file per gene) can be downloaded from the IMGT/HLA database, maybe best from their FTP server.
> If you look into the alignment files, you will realize that those are even up to 8-digit level (e.g. B*07:02:01:01, B*07:02:01:02,…). Amino acid sequences are however only different up to 4-digit level. So the first step would be to reduce that to 4-digit, by only keeping e.g. the first out of “B*07:02:01:01, B*07:02:01:02,…”, and rename it to “B*07:02”. The format should then be compatible with the imported HLA allele calls.
> The goal is to get a new data frame / object with all variable amino acid positions.

The protein level alignment files have been downloaded from the EBI database and
are shipped together with the package. Since we are using EBI format files it 
should make it easy for user to supply thier own alignment files if nessesary.
The package provides `readHlaAlignments` function for reading those alignments.
By default the alignments are trimmed so only mature protein aa are present, but
it's also possible to skip the trimming if needed.

Amino acid sequences differ only up to 4-digit level, thus it might be nessesary
to reduce HLA numbers, this can be achived using `reduceAlleleResolution`.

Finally the get the amino acid variation inference functionality package 
provides `hlaToAAVariation` function. This function will take the HLA calls 
table and return matrix holding all variable aa positions.

The example:
```{r aa_var_inference}
# readHlaAlignments reads alignment files
# alignment_file <- system.file("extdata", "A_prot.txt", package = "MiDAS")
# alignment <- readHlaAlignments(alignment_file, trim = TRUE, unkchar = "")
# now we can also just specify gene name
alignment <- readHlaAlignments(gene = "A", trim = TRUE, unkchar = "")

kable(alignment[, 1:20]) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(width = "100%", height = "200px")

# reduceAlleleResolution make it possible to reduce HLA numbers resolution
alleles <- c("A*01:01:01:01", "A*01:01:01:02N", "A*01:01:01:03", "A*01:01:01:04", "A*01:01:01:05")
print(alleles)
reduceAlleleResolution(alleles, resolution = 4)

# hlaToAAVariation can be used to get variable amino acids positions
# We can choose if indels and unkchar should be taken into account or not
aa_variation <- hlaToAAVariation(hla_calls, indels = TRUE, unkchar = FALSE)

kable(aa_variation[, 1:50]) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(width = "100%", height = "200px")
```

#### list of HLA alleles for amino acid residues at a given position
> Also, but with less priority, it would be great to be able to get a list of HLA alleles for amino acid residues at a given position. Let's say we find a strong association of position 9 in HLA-A: What alleles (maybe with an allele frequency cutoff) have which amino acid residue at this position?

Since the alignment files are simple matrices specific positions can be simply
indexed. However I understand that here we would like to have something more
specific - clarification needed.
```{r aa_frequency}
table(alignment[, 5])
```

### Conversion of 4-digit alleles in supertypes, and to 2-digit level
> An additional function to convert 4-digit alleles to 2-digit alleles would be helpful. That should be quite simple, just removing digits 3-4. Example: A*02:01 to A*02. I wouldn’t want to analyze on 2-digit level primarily, but it’s useful to compare results to published data, and to group alleles in case of low statistical power.
> The same holds true for supertypes, which group 4-digit alleles (but only for HLA-A and HLA-B) into these supertypes by their binding specificity to antigens. There are 12 supertypes (6 each for HLA-A and HLA-B), and not all 4-digit alleles can be matched to a supertype.

Conversion of 4-digit alleles in 2-digit level can be done with help of 
`reduceAlleleResolution`. 

The conversion to supertypes and other additional variables can be achived using
`hlaToVariable` function. It converts the hla calls data frame based on the 
supplied match table. It can be a tsv file or data frame. For the files provided
by Chris, I've made it that you can refere them by passing one of the strings:
2digit_A-allele_expression, 2digit_C-allele_expression, 4digit_allele_Ggroup,
4digit_B-allele_Bw, 4digit_C-allele_C1-2, 4digit_supertype. As you can see
I've added the resolution parameter thier names so it obvius which conversions
they code.
```{r hla_numbers_coversion}
# 4-digit alleles in supertypes, and to 2-digit level
alleles <- c("A*01:01:01:01", "A*01:01:01:02N", "A*01:01:01:03", "A*01:01:01:04", "A*01:01:01:05")
print(alleles)
reduceAlleleResolution(alleles, resolution = 2)

hla_calls <- system.file("extdata/HLAHD_output_example.txt", package = "MiDAS")
hla_calls <- readHlaCalls(hla_calls, resolution = 4)
supertypes <- hlaToVariable(hla_calls, dictionary = "4digit_supertype")
kable(supertypes) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  scroll_box(width = "100%", height = "200px")
```

###Calculation of allelic distance per gene
TODO

###Import of inferred KIR types
TODO

### Functions not described above
There are also some usefull functions in MiDAS package that do not directly
answers any of the above problems.

```{r}
allele <- c("A*01:01", "A*01:02")
getAlleleResolution(allele)

file <- system.file("extdata", "A_prot.txt", package = "MiDAS")
alignment <- readHlaAlignments(file)
getVariableAAPos(alignment)
```
